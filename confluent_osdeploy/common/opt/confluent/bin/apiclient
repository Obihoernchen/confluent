#!/usr/bin/python
try:
    import http.client as client
except ImportError:
    import httplib as client
import ctypes
import ctypes.util
import os
import socket
import subprocess
import ssl
import sys
import time

class InvalidApiKey(Exception):
    pass

c_libcrypt = ctypes.CDLL(ctypes.util.find_library('crypt'))
c_crypt = c_libcrypt.crypt
c_crypt.argtypes = (ctypes.c_char_p, ctypes.c_char_p)
c_crypt.restype = ctypes.c_char_p


def get_net_apikey(nodename, mgr):
    alpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789./'
    newpass = ''.join([alpha[x >> 2] for x in bytearray(os.urandom(32))])
    salt = '$5$' + ''.join([alpha[x >> 2] for x in bytearray(os.urandom(8))])
    newpass = newpass.encode('utf8')
    salt = salt.encode('utf8')
    crypted = c_crypt(newpass, salt)
    for addrinfo in socket.getaddrinfo(mgr, 13001, type=socket.SOCK_STREAM):
        try:
            clisock = socket.socket(addrinfo[0], addrinfo[1])
            clisock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            if addrinfo[0] == socket.AF_INET:
                cliaddr = ('0.0.0.0', 302)
            else:
                cliaddr = ('::', 302)
            clisock.bind(cliaddr)
            clisock.connect(addrinfo[-1])
            rsp = clisock.recv(8)
            if rsp != b'\xc2\xd1-\xa8\x80\xd8j\xba':
                raise Exception('Unrecognized credential banner')
            hellostr = bytearray([1, len(nodename)]) + bytearray(nodename.encode('utf8')) + bytearray(b'\x00\x00')
            clisock.send(hellostr)
            rsp = bytearray(clisock.recv(2))
            if not rsp:
                continue
            if rsp[0] == 128:
                continue
            if rsp[0] == 2:
                echotoken = clisock.recv(rsp[1])
                clisock.recv(2)  # drain \x00\x00
                clisock.send(bytes(bytearray([3, rsp[1]])))
                clisock.send(echotoken)
                clisock.send(bytes(bytearray([4, len(crypted)])))
                clisock.send(crypted)
                clisock.send(b'\x00\x00')
            rsp = bytearray(clisock.recv(2))
            if rsp[0] == 5:
                return newpass.decode('utf8')
        finally:
            clisock.close()
    return ''


def get_apikey(nodename, mgr, mgr6=None):
    apikey = ""
    if os.path.exists('/etc/confluent/confluent.apikey'):
        apikey = open('/etc/confluent/confluent.apikey').read().strip()
        if apikey:
            return apikey
    hosts = []
    for host in (mgr, mgr6):
        if not host:
            continue
        hosts.append(host)
    while not apikey:
        for host in hosts:
            apikey = get_net_apikey(nodename, host)
            if apikey:
                break
        if not apikey:
            sys.stderr.write(
                "Failed getting API token, check deployment.apiarmed attribute on {}\n".format(nodename))
            time.sleep(10)
    with open('/etc/confluent/confluent.apikey', 'w+') as apiout:
        apiout.write(apikey)
    apikey = apikey.strip()
    os.chmod('/etc/confluent/confluent.apikey', 0o600)
    return apikey

class HTTPSClient(client.HTTPConnection, object):
    def __init__(self, json=False, port=443):
        self.stdheaders = {}
        info = open('/etc/confluent/confluent.info').read().split('\n')
        host = None
        mgtiface = None
        havedefault = '0'
        for line in info:
            if line.startswith('NODENAME:'):
                node = line.split(' ')[1]
                self.stdheaders['CONFLUENT_NODENAME'] = node
            if line.startswith('MANAGER:') and not host:
                host = line.split(' ')[1]
            if line.startswith('EXTMGRINFO:'):
                extinfo = line.split(' ')[1]
                extinfo = extinfo.split('|')
                if not mgtiface:
                    host, mgtiface, havedefault = extinfo[:3]
                if havedefault == '0' and extinfo[2] == '1':
                    host, mgtiface, havedefault = extinfo[:3]
        if '%' in host:
            ifidx = host.split('%', 1)[1]
            with open('/tmp/confluent.ifidx', 'w+') as ifout:
                ifout.write(ifidx)
        v4srv = None
        v6srv = None
        if ':' in host:
            v6srv = host
        else:
            v4srv = host
        if json:
            self.stdheaders['ACCEPT'] = 'application/json'
        try:
            info = open('/etc/confluent/confluent.deploycfg').read().split('\n')
        except Exception:
            info = None
        if info:
            for line in info:
                if line.startswith('deploy_server: '):
                    v4srv = line.split(': ', 1)[1]
                if line.startswith('deploy_server_v6: '):
                    v6srv = line.split(': ', 1)[1]
        self.stdheaders['CONFLUENT_APIKEY'] = get_apikey(node, v4srv, v6srv)
        if mgtiface:
            self.stdheaders['CONFLUENT_MGTIFACE'] = mgtiface
        self.v4srv = v4srv
        self.v6srv = v6srv
        self.port = port
        self.host = None
        self.node = node
        host = self.check_connections()
        client.HTTPConnection.__init__(self, host, port)
        self.connect()


    def set_header(self, key, val):
        self.stdheaders[key] = val

    def check_connections(self):
        foundsrv = None
        hosts = []
        if self.v4srv:
            hosts.append(self.v4srv)
        if self.v6srv:
            hosts.append(self.v6srv)
        for timeo in (0.1, 10):
            for host in hosts:
                try:
                    addrinf = socket.getaddrinfo(host, self.port)[0]
                    psock = socket.socket(addrinf[0])
                    psock.settimeout(timeo)
                    psock.connect(addrinf[4])
                    foundsrv = host
                    psock.close()
                    break
                except OSError:
                    continue
            else:
                continue
            break
        if not foundsrv:
            raise Exception('Unable to reach any hosts')
        return foundsrv

    def connect(self):
        addrinf = socket.getaddrinfo(self.host, self.port)[0]
        psock = socket.socket(addrinf[0])
        psock.connect(addrinf[4])
        ctx = ssl.SSLContext(ssl.PROTOCOL_SSLv23)
        ctx.load_verify_locations('/etc/confluent/ca.pem')
        host = self.host.split('%', 1)[0]
        if '[' not in host and ':' in host:
            self.stdheaders['Host'] = '[{0}]'.format(host)
        else:
            self.stdheaders['Host'] = '{0}'.format(host)
        ctx.verify_mode = ssl.CERT_REQUIRED
        ctx.check_hostname = True
        self.sock = ctx.wrap_socket(psock, server_hostname=host)

    def grab_url(self, url, data=None, returnrsp=False):
        return self.grab_url_with_status(url, data, returnrsp)[1]

    def grab_url_with_status(self, url, data=None, returnrsp=False):
        if data:
            method = 'POST'
        else:
            method = 'GET'
        authed = False
        while not authed:
            authed = True
            self.request(method, url, data, headers=self.stdheaders)
            rsp = self.getresponse()
            if rsp.status >= 200 and rsp.status < 300:
                if returnrsp:
                    return rsp.status, rsp
                else:
                    return rsp.status, rsp.read()
            if rsp.status == 401:
                authed = False
                rsp.read()
                with open('/etc/confluent/confluent.apikey', 'w+') as akfile:
                    akfile.write('')
                self.stdheaders['CONFLUENT_APIKEY'] = get_apikey(
                    self.node, self.host)
        raise Exception(rsp.read())

if __name__ == '__main__':
    data = None
    json = False
    if '-j' in sys.argv:
        json = True
    if len(sys.argv) == 1:
        HTTPSClient()
        sys.exit(0)
    try:
        outbin = sys.argv.index('-o')
        sys.argv.pop(outbin)
        outbin = sys.argv.pop(outbin)
    except ValueError:
        outbin = None
    try:
        waitfor = sys.argv.index('-w')
        sys.argv.pop(waitfor)
        waitfor = int(sys.argv.pop(waitfor))
    except ValueError:
        waitfor = None
    try:
        data = sys.argv.index('-d')
        sys.argv.pop(data)
        data = sys.argv.pop(data)
    except ValueError:
        data = None
    if outbin:
        with open(outbin, 'ab+') as outf:
            reader = HTTPSClient(json=json).grab_url(
                sys.argv[1], data, returnrsp=True)
            chunk = reader.read(16384)
            while chunk:
                outf.write(chunk)
                chunk = reader.read(16384)
        sys.exit(0)
    if len(sys.argv) > 2 and os.path.exists(sys.argv[-1]):
        data = open(sys.argv[-1]).read()
    if waitfor:
        client = HTTPSClient(json=json)
        status = 201
        while status != waitfor:
            status, rsp = client.grab_url_with_status(sys.argv[1], data)
            sys.stdout.write(rsp.decode())
    else:
        sys.stdout.write(HTTPSClient(json=json).grab_url(sys.argv[1], data).decode())
